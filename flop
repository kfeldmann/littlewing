#!/usr/bin/python2.7 -O

"""
Terraflop: Simple, powerful infrastructure automation.
https://github.com/kfeldmann/terraflop

Copyright (c) 2016, Kris Feldmann
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above
     copyright notice, this list of conditions and the following
     disclaimer in the documentation and/or other materials provided
     with the distribution.

  3. Neither the name of the copyright holder nor the names of its
     contributors may be used to endorse or promote products derived
     from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""

import sys
import yaml
import json
import os
import re
import subprocess
from urllib import quote, unquote
import time

AWSCLI = os.environ.get('AWSCLI', 'aws')
filename = '(none)'
lineno = '(none)'
stepno = '(none)'

def _err(message):
    """
    Write error message to stderr along with filename,
    stepno, and lineno, and then exit(1).
    """
    sys.stderr.write('ERROR: file: %s, step: %s, line: %s\n' \
                    % (filename, stepno, lineno))
    sys.stderr.write('ERROR: %s\n' % message)
    raise SystemExit(1)

def _wrn(message):
    """
    Write warning message to stderr along with filename,
    stepno, and lineno.
    """
    sys.stderr.write('WARN: file: %s, step: %s, line: %s\n' \
                    % (filename, stepno, lineno))
    sys.stderr.write('WARN: %s\n' % message)
    return None

def _inf(message):
    "Write informational message to stdout."
    sys.stdout.write('INFO: %s\n' % message)
    return None

def _dbg(message):
    """
    If the environment variable DEBUG has been set, write
    debugging message to stdout.
    """
    if os.environ.get('DEBUG', False):
        sys.stdout.write('DEBUG: %s\n' % message)
    return None

def usage():
    "Write usage statement to stderr and exit(2)."
    sys.stderr.write('Usage: flop [-l|--list|<target>]\n')
    raise SystemExit(2)

def __varsub(in_str):
    "Dereference variables and output references."
    _dbg('__varsub(): starting with in_str = %s' % in_str)
    words = in_str.split('.')
    _dbg('__varsub(): words = %s' % repr(words))
    if words[0] == 'var':
        if len(words) == 2:
            if words[1] in var:
                return var[words[1]]
            else:
                raise ValueError('Unknown variable: %s' % words[1])
        elif len(words) == 3:
            if words[1] in var:
                if words[2] in var[words[1]]:
                    return var[words[1]][words[2]]
                else:
                    raise ValueError('Unknown variable: %s.%s' % (words[1], words[2]))
            else:
                raise ValueError('Unknown variable: %s.%s' % (words[1], words[2]))
    if words[0] == 'aws':
        fname = '.'.join(words[:4])
    elif words[0] == 'exec':
        fname = '.'.join(words[:3])
    else:
        _err('Unknown provider: %s' % words[0])
    try:
        f = open('.terraflop-output/%s' % fname, 'r')
        filename = '.terraflop-output/%s' % fname
    except IOError:
        _err('Unknown resource: %s' % fname)
    lineno = 0
    while True:
        line = f.readline()
        lineno += 1
        if line == '':
            break
        line = line.strip()
        try:
            n, v = line.split(':', 1)
        except ValueError:
            f.close()
            _err('Malformed line in output file (%s): %s' % (fname, line))
        if n == in_str:
            f.close()
            return unquote(v)
    f.close()
    _err('Unknown resource attribute: %s' % in_str)

def varsub(val):
    """
    Recursively (to a limit) find variables in the input string
    and call __varsub() to dereference them.
    """
    _dbg('varsub(): starting with val = %s' % val)
    if isinstance(val, None.__class__):
        return val
    if isinstance(val, int):
        return str(val)
    i = 0
    while i < 10:
        # Do we want to add an argument (or statement
        # in configurations) to switch between formats?
        #s = re.search(r'\$\{([^${}]+)\}', val)
        s = re.search(r'\~\{([^~{}]+)\}', val)
        try:
            s.group(1)
        except (IndexError, AttributeError):
            break
        _dbg('varsub(): s.group(0) = %s' % s.group(0))
        _dbg('varsub(): s.group(1) = %s' % s.group(1))
        needle = s.group(0).replace('$', r'\$')
        val = re.sub(needle, __varsub(s.group(1)), val)
        i += 1
    return val

def aws_call(region, profile, cmdtuple, argtuple):
    "Spawn aws-cli subprocess to execute commands."
    if (not region) or (not profile):
        _err('Must set region and profile before calling aws.')
    args = [
            AWSCLI,
            '--region', region,
            '--profile', profile
           ]
    args.extend(cmdtuple)
    if argtuple:
        args.extend(argtuple)
    try:
        outdata = subprocess.check_output(args)
    except Exception as ex:
        _err('Failed to run %s %s %s: %s\n' \
             % (AWSCLI, cmdtuple[0], cmdtuple[1], ex) \
             + 'ERROR: Args: %s' % repr(args))
    if outdata: # Some calls do not return data
        try:
            outdict = json.loads(outdata)
        except Exception as ex:
            _err( \
            """Failed to parse json response from %s %s %s.
            Exception is: %s
            JSON source:
            %s
            """ % (AWSCLI, cmdtuple[0], cmdtuple[1], ex, outdata))
    else:
        outdict = None
    return outdict

def exec_call(cmd, argtuple):
    "Spawn subprocess to execute <cmd>."
    args = [cmd]
    args.extend(argtuple)
    try:
        outdata = subprocess.check_output(args)
    except Exception as ex:
        _err('Failed to run %s: %s' % (cmd, ex))
    return {'Output': outdata}

def stringify(path, name, obj):
    """
    Recursively convert heirarchical object into a list of strings,
    each using a dotted notation to represent the branch to each
    attribute and its value.
    """
    strings = []
    if obj == None:
        return strings
    if isinstance(obj, dict):
        for k in obj.keys():
            strings.extend(stringify('%s.%s' % (path, name), k, obj[k]))
    elif isinstance(obj, list):
        i = 0
        for item in obj:
            strings.extend(stringify('%s.%s' % (path, name), i, item))
            i += 1
    else:
        this = '%s.%s:%s' % (path, name, quote(str(obj)))
        strings.append(this.strip('.'))
    return strings

def store_output(name, outdict):
    "Stringify and write out the output data from a step."
    try:
        f = open('.terraflop-output/%s' % name, 'w')
    except IOError:
        _err('Failed to open output file: %s' % name)
    for line in stringify('', name, outdict):
        f.write('%s\n' % line)
    f.close()
    return None

def clear_all_output():
    "Move all output aside, effectively clearing it."
    ts = time.strftime('%Y%m%d%H%M%S', time.localtime())
    os.rename('.terraflop-output', '.terraflop-output-cleared-%s' % ts)
    os.mkdir('.terraflop-output')
    return None

def varsub_tuple(intuple):
    "Substitute variables in each element of a tuple."
    if intuple == None:
        return None
    outtuple = []
    for item in intuple:
        outtuple.append(varsub(item))
    return outtuple

### main ###

if len(sys.argv) > 2 \
        or  '-?' in sys.argv \
        or '-h' in sys.argv \
        or '--help' in sys.argv:
    usage()

listing = False
target = None
default_found = False

if len(sys.argv) == 2:
    if sys.argv[1] in ('-l', '--list'):
        listing = True
    else:
        target = sys.argv[1]

if not os.path.exists('.terraflop-output'):
    os.mkdir('.terraflop-output')

all_files = os.listdir('.')
input_files = []
for f in all_files:
    if f[-4:] == '.yml':
        input_files.append(f)
input_files.sort()

region = None
profile = None
var = {}
target_groups = {}
var['USER'] = os.environ.get('USER', 'terraflop')

for in_file in input_files:
    f = open(in_file, 'r')
    filename = in_file
    lineno = '(yaml)'
    yd = yaml.load(f)
    f.close()

    # Have to make sure we load all the vars, target-groups,
    # default-target, and set region/profile before
    # running the steps.
    if listing:
        _inf('File: %s' % filename)

    # Try up to 10 passes to resolve variable dependencies
    z = 0
    vardep_keep_going = False
    while True:
        z += 1
        for k in yd.keys():
            lineno = '(%s...)' % str(k)[:10]
            if k == 'region':
                try:
                    region = varsub(yd[k])
                    var['REGION'] = region
                except ValueError as ex:
                    if z >= 10:
                        _err(str(ex))
                    else:
                        vardep_keep_going = True
            elif k == 'profile':
                try:
                    profile = varsub(yd[k])
                    var['PROFILE'] = profile
                except ValueError as ex:
                    if z >= 10:
                        _err(str(ex))
                    else:
                        vardep_keep_going = True
            elif k[:4] == 'var.':
                if isinstance(yd[k], basestring):
                    try:
                        var[k[4:]] = varsub(yd[k])
                        _dbg('Set string var[%s] = "%s"' % (k[4:], var[k[4:]]))
                    except ValueError as ex:
                        if z >= 10:
                            _err(str(ex))
                        else:
                            vardep_keep_going = True
                elif isinstance(yd[k], int):
                    var[k[4:]] = str(yd[k])
                    _dbg('Set int var[%s] = "%s"' % (k[4:], var[k[4:]]))
                else:
                    var[k[4:]] = yd[k]
                    _dbg('Set other var[%s] = "%s"' % (k[4:], var[k[4:]]))
            elif k == 'default-target':
                if not target:
                    if isinstance(yd[k], basestring):
                        try:
                            target = varsub(yd[k])
                            if listing:
                                default_found = True
                        except ValueError as ex:
                            if z >= 10:
                                _err(str(ex))
                            else:
                                vardep_keep_going = True
                    else:
                        _wrn('Default target must be a string.')
            elif k == 'target-groups':
                if not isinstance(yd[k], dict):
                    _wrn("'target-groups' must be a dict.")
                    continue
                for tgname in yd[k].keys():
                    if not isinstance(yd[k][tgname], list):
                        _wrn("'target-groups: %s' must be a list." % tgname)
                        continue
                    try:
                        target_groups[tgname] = varsub_tuple(yd[k][tgname])
                    except ValueError as ex:
                        if z >= 10:
                            _err(str(ex))
                        else:
                            vardep_keep_going = True
        if (z >= 10) or not vardep_keep_going:
            break

    # List targets
    if listing:
        if default_found:
            _inf('Default target: %s' % target)
        else:
            _inf('Default target: (all steps)')
        for tgname in target_groups.keys():
            _inf('[%s]: %s' \
                % (tgname, ', '.join(target_groups[tgname])))
        for k in yd.keys():
            if k[:5] == 'steps':
                tgt = varsub(k[6:])
                if tgt:
                    _inf(tgt)
                else:
                    if default_found:
                        _inf('(targetless - not reachable since ' \
                            + 'default target has been set)')
                    else:
                        _inf('(targetless)')
        continue

    # Make the targets in a target-group run in order
    if target and target in target_groups.keys():
        goals = target_groups[target]
    elif target:
        goals = [target]
    else:
        goals = [None]
    for goal in goals:
        for k in yd.keys():
            if k[:5] == 'steps':
                tgt = varsub(k[6:])
                if goal and tgt != goal:
                    _dbg('Skipping %s (target: %s, goal: %s)' \
                         % (tgt, target, goal))
                    continue
                _dbg('Examining step list %s' % k)
                stepno = 0
                for step in yd[k]:
                    stepno += 1
                    step_key = step.keys()[0]
                    lineno = '(%s)' % step_key
                    rsrc_pathname = varsub(step_key)
                    if rsrc_pathname == 'print':
                        if isinstance(step[step_key], basestring):
                            print varsub(step[step_key])
                        else:
                            _wrn('%s %s' \
                             % ('Print statements can only use string',
                                'arguments (with or without variables).'))
                        continue
                    if rsrc_pathname == 'clear-all-output':
                        if step[step_key]:
                            _inf('Running %s' % rsrc_pathname)
                            clear_all_output()
                        continue
                    if rsrc_pathname == 'region':
                        region = varsub(step[step_key])
                        var['REGION'] = region
                        continue
                    if rsrc_pathname == 'profile':
                        profile = varsub(step[step_key])
                        var['PROFILE'] = profile
                        continue
                    if rsrc_pathname[:4] == 'var.':
                        ky = rsrc_pathname[4:]
                        rawval = step[step_key]
                        if isinstance(rawval, basestring):
                            var[ky] = varsub(rawval)
                            _dbg('Set string var[%s] = "%s"' % (ky, var[ky]))
                        elif isinstance(rawval, int):
                            var[ky] = str(rawval)
                            _dbg('Set int var[%s] = "%s"' % (ky, var[ky]))
                        else:
                            var[ky] = rawval
                            _dbg('Set other var[%s] = "%s"' % (ky, var[ky]))
                        continue
                    if os.path.exists('.terraflop-output/%s' \
                                     % rsrc_pathname):
                        _dbg('%s has already been run.' % rsrc_pathname)
                        continue
                    if rsrc_pathname[0] == '+':
                        rsrc_pathname = rsrc_pathname[1:]
                    words = rsrc_pathname.split('.')
                    if words[0] == 'aws':
                        cmdtuple = (words[1], words[2])
                        argtupleraw = step[step_key]
                        _inf('Running %s' % rsrc_pathname)
                        outdict = aws_call(
                            region, profile, cmdtuple,
                            varsub_tuple(argtupleraw))
                        store_output(rsrc_pathname, outdict)
                    elif words[0] == 'exec':
                        cmd = words[1]
                        argtupleraw = step[step_key]
                        _inf('Running %s' % rsrc_pathname)
                        outdict = exec_call(
                            cmd, varsub_tuple(argtupleraw))
                        store_output(rsrc_pathname, outdict)
                    elif words[0] == 'ssh':
                        argtupleraw = step[step_key]
                        _inf('Running %s' % rsrc_pathname)
                        args = ['ssh']
                        args.extend(varsub_tuple(argtupleraw))
                        response = subprocess.call(args)
                    else:
                        _err('Unrecognized provider: %s' % words[0])

